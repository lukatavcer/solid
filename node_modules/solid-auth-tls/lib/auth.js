'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

/* global XMLHttpRequest */

var defaultConfig = require('./config-default');

/**
 * Note:
 *
 * global.IS_BROWSER is a global made available by a webpack plugin.
 * If you're using this library in the browser you must include the folowing
 * configuration in your webpack config (or equivalent):
 *   module.exports = {
 *     ...,
 *     plugins: [
 *       new webpack.DefinePlugin({ global.IS_BROWSER: true }),
 *     ]
 *   }
 */

/**
 * Enumerates the two main types of authentication endpoints.
 * @readonly
 * @enum {number}
 */
var AUTH_ENDPOINTS = {
  PRIMARY: 0,
  SECONDARY: 1
};

/**
 * "Logs in"* to a WebID-TLS server by sending a HEAD request.  The TLS
 * handshake happens implicitly through either an 'XMLHttpRequest' or node
 * 'https.request'.
 *
 * First tries to log in to the "primary" WebID-TLS endpoint, and retries with
 * the "fallback" endpoint if the first attempt fails.
 *
 * @param {Object} config - the configuration object specified in {@link
 * module:config-default}.
 * @returns {(Promise<String>|Promise<null>)} the WebID as a string if the
 * client cert is recognized, otherwise null.
 */
function login(config) {
  config = Object.assign({}, defaultConfig, config);
  return loginTo(AUTH_ENDPOINTS.PRIMARY, config).then(function (webId) {
    return webId || loginTo(AUTH_ENDPOINTS.SECONDARY, config);
  });
}

/**
 * Alias to {@link login}
 */
var currentUser = login;

/**
 * Logs in to the specified endpoint with the given configuration
 * @param {AUTH_ENDPOINTS} endpoint - the endpoint type
 * @param {@link module:config-default} config - the config object
 * @returns {(Promise<String>|Promise<null>)} the WebID as a string if the
 * client cert is recognized, otherwise null.
 */
function loginTo(endpoint, config) {
  return global.IS_BROWSER ? loginFromBrowser(endpoint, config) : loginFromNode(endpoint, config);
}

/**
 * Logs in to the specified endpoint from within the browser
 * @param {AUTH_ENDPOINTS} endpoint - the endpoint type
 * @param {@link module:config-default} config - the config object
 * @returns {(Promise<String>|Promise<null>)} the WebID as a string if the
 * client cert is recognized, otherwise null.
 */
function loginFromBrowser(endpoint, config) {
  var uri = void 0;

  switch (endpoint) {
    case AUTH_ENDPOINTS.PRIMARY:
      uri = config.authEndpoint || window.location.origin + window.location.pathname;
      break;
    case AUTH_ENDPOINTS.SECONDARY:
      uri = config.fallbackAuthEndpoint;
      break;
  }

  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = true;
    xhr.addEventListener('load', function () {
      resolve(xhr.getResponseHeader('user') || null);
    });
    xhr.addEventListener('error', function (err) {
      reject(err);
    });
    xhr.open('HEAD', uri);
    xhr.send();
  });
}

/**
 * Logs in to the specified endpoint from within a Node.js environment
 * @param {AUTH_ENDPOINTS} endpoint - the endpoint type
 * @param {@link module:config-default} config - the config object
 * @returns {(Promise<String>|Promise<null>)} the WebID as a string if the
 * client cert is recognized, otherwise null.
 */
function loginFromNode(endpoint, config) {
  if (!(config.key && config.cert)) {
    throw new Error('Must provide TLS key and cert when running in node');
  }

  var uri = void 0;

  switch (endpoint) {
    case AUTH_ENDPOINTS.PRIMARY:
      uri = config.authEndpoint;
      break;
    case AUTH_ENDPOINTS.SECONDARY:
      uri = config.fallbackAuthEndpoint;
      break;
  }

  var fs = void 0,
      https = void 0,
      url = void 0;

  if (!global.IS_BROWSER) {
    fs = require('fs');
    https = require('https');
    url = require('url');
  }

  return Promise.all([config.key, config.cert].map(function (filename) {
    return new Promise(function (resolve, reject) {
      fs.readFile(filename, function (err, data) {
        return err ? reject(err) : resolve(data);
      });
    });
  })).then(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        keyBuf = _ref2[0],
        certBuf = _ref2[1];

    var parsedUrl = url.parse(uri);
    var options = {
      method: 'HEAD',
      hostname: parsedUrl.hostname,
      port: parsedUrl.port,
      path: parsedUrl.path,
      timeout: 5000,
      key: keyBuf,
      cert: certBuf
    };
    return new Promise(function (resolve, reject) {
      var req = https.request(options, function (res) {
        resolve(res.headers['user'] || null);
      });
      req.on('error', reject);
      req.end();
    });
  });
}

module.exports = {
  currentUser: currentUser,
  login: login
};