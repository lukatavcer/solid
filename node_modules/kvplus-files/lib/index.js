'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var path = require('path');
var fs = require('fs-extra');

var KVPFileStore = function () {
  /**
   * @constructor
   *
   * @param [options={}] {Object}
   * @param [options.path] {string}
   * @param [options.collections] {Array<string>}
   * @param [options.filePrefix] {string}
   * @param [options.fileExt] {string}
   */
  function KVPFileStore() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, KVPFileStore);

    this.path = options.path || './db';
    this.collections = options.collections || [];
    this.filePrefix = options.filePrefix || '_key_';
    this.fileExt = options.fileExt || 'json';

    // Set up default serialize/deserialize hooks
    // These can be overridden by the client after instantiation
    this.serialize = function (data) {
      return typeof data === 'string' ? data : JSON.stringify(data);
    };
    this.deserialize = function (data) {
      try {
        data = JSON.parse(data);
      } catch (error) {
        console.error('Error deserializing object: ', error);
      }
      return data;
    };
  }

  /**
   * @method absolutePathFor
   * @private
   * @param {string} collectionName
   * @param {string} key
   * @return {string}
   */


  _createClass(KVPFileStore, [{
    key: 'absolutePathFor',
    value: function absolutePathFor(collectionName, key) {
      return path.resolve(this.relativePathFor(collectionName, key));
    }

    /**
     * @method createCollection
     * @param {string} collectionName
     * @throws {TypeError} If collection name is a falsy value.
     * @throws {Error} fs error
     * @return {Promise}
     */

  }, {
    key: 'createCollection',
    value: function createCollection(collectionName) {
      if (!collectionName) {
        return Promise.reject(new TypeError('Cannot create empty collection name'));
      }
      var collectionPath = this.absolutePathFor(collectionName);
      return new Promise(function (resolve, reject) {
        fs.mkdirp(collectionPath, function (err) {
          if (err) {
            return reject(err);
          } else {
            return resolve(true);
          }
        });
      });
    }

    /**
     * @private
     * @param collectionName
     */

  }, {
    key: 'createCollectionSync',
    value: function createCollectionSync(collectionName) {
      if (!collectionName) {
        throw new TypeError('Cannot create empty collection name');
      }
      var collectionPath = this.absolutePathFor(collectionName);
      fs.mkdirpSync(collectionPath);
    }

    /**
     * @method del
     * @param {string} collectionName
     * @param {string} key
     * @throws {TypeError} If collection name or key is a falsy value.
     * @throws {Error} fs error
     * @return {Promise<Boolean>}
     */

  }, {
    key: 'del',
    value: function del(collectionName, key) {
      if (!collectionName) {
        return Promise.reject(new TypeError('Cannot call del() using an empty collection name'));
      }
      if (!key) {
        return Promise.reject(new TypeError('Cannot call del() using an empty key'));
      }
      var filePath = this.absolutePathFor(collectionName, key);
      return new Promise(function (resolve, reject) {
        fs.unlink(filePath, function (err) {
          if (!err) {
            return resolve(true);
          }
          if (err.code === 'ENOENT') {
            return resolve(false);
          }
          return reject(err);
        });
      });
    }

    /**
     * @method exists
     * @param {string} collectionName
     * @param {string} key
     * @throws {TypeError} If collection name or key is a falsy value.
     * @throws {Error} fs error
     * @return {Promise<Boolean>}
     */

  }, {
    key: 'exists',
    value: function exists(collectionName, key) {
      if (!collectionName) {
        return Promise.reject(new TypeError('Cannot call exists() using an empty collection name'));
      }
      if (!key) {
        return Promise.reject(new TypeError('Cannot call exists() using an empty key'));
      }
      var filePath = this.absolutePathFor(collectionName, key);
      return new Promise(function (resolve, reject) {
        fs.access(filePath, fs.R_OK | fs.W_OK, function (err) {
          if (!err) {
            return resolve(true);
          }
          if (err.code === 'ENOENT') {
            return resolve(false);
          }
          return reject(err);
        });
      });
    }

    /**
     * @private
     * @param key {string}
     * @return {string}
     */

  }, {
    key: 'fileNameFor',
    value: function fileNameFor(key) {
      return '' + this.filePrefix + key + '.' + this.fileExt;
    }

    /**
     * @method get
     * @param {string} collectionName
     * @param {string} key
     * @throws {TypeError} If collection name or key is a falsy value.
     * @throws {Error} fs error
     * @return {Promise<Object>}
     */

  }, {
    key: 'get',
    value: function get(collectionName, key) {
      var _this = this;

      var filePath = this.absolutePathFor(collectionName, key);
      return new Promise(function (resolve, reject) {
        fs.readFile(filePath, function (err, result) {
          if (!err) {
            if (_this.deserialize) {
              result = _this.deserialize(result);
            }
            return resolve(result);
          }
          if (err.code === 'ENOENT') {
            return resolve(null);
          }
          return reject(err);
        });
      });
    }
  }, {
    key: 'initCollections',
    value: function initCollections() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.collections[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var collectionName = _step.value;

          this.createCollectionSync(collectionName);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * @private
     * @param collectionName {string}
     * @param key {string}
     * @throws {TypeError}
     * @return {string}
     */

  }, {
    key: 'relativePathFor',
    value: function relativePathFor(collectionName, key) {
      if (!collectionName) {
        throw new TypeError('Cannot resolve path for an empty collection name');
      }
      var relPath = path.join(this.path, collectionName);
      if (key) {
        relPath = path.join(relPath, this.fileNameFor(key));
      }
      return relPath;
    }

    /**
     * @method put
     * @param {string} collectionName
     * @param {string} key
     * @param {Object} data
     * @throws {TypeError} If collection name or key is a falsy value.
     * @throws {Error} fs error
     * @return {Promise}
     */

  }, {
    key: 'put',
    value: function put(collectionName, key, data) {
      if (!collectionName) {
        return Promise.reject(new TypeError('Cannot put() using an empty collection name'));
      }
      if (!key) {
        return Promise.reject(new TypeError('Cannot put() using an empty key'));
      }
      var filePath = this.absolutePathFor(collectionName, key);
      if (this.serialize) {
        data = this.serialize(data);
      }
      return new Promise(function (resolve, reject) {
        fs.writeFile(filePath, data, function (err) {
          if (!err) {
            return resolve(true);
          }
          if (err.code === 'ENOENT') {
            return reject(new Error('Error in put() - collection ' + JSON.stringify(collectionName) + ' does not exist'));
          } else {
            return resolve(true);
          }
        });
      });
    }
  }]);

  return KVPFileStore;
}();

module.exports = KVPFileStore;