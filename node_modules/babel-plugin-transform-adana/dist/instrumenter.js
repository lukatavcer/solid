'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.skip = skip;
exports.key = key;
exports.default = instrumenter;

var _babelCore = require('babel-core');

var _prelude = require('./prelude');

var _prelude2 = _interopRequireDefault(_prelude);

var _meta = require('./meta');

var _meta2 = _interopRequireDefault(_meta);

var _tags = require('./tags');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function skip() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      opts = _ref.opts,
      file = _ref.file;

  if (file && opts) {
    var _opts$ignore = opts.ignore,
        _ignore = _opts$ignore === undefined ? [] : _opts$ignore,
        only = opts.only;

    return _babelCore.util.shouldIgnore(file.opts.filename, _babelCore.util.arrayify(_ignore, _babelCore.util.regexify), only ? _babelCore.util.arrayify(only, _babelCore.util.regexify) : null);
  }
  return false;
}

/**
 * Create an opaque, unique key for a given node. Useful for tagging the node
 * in separate places.
 * @param {Object} path Babel path to derive key from.
 * @returns {String} String key.
 */
function key(path) {
  var node = path.node;
  if (node.loc) {
    var location = node.loc.start;
    return location.line + ':' + location.column;
  }
  throw new TypeError('Path must have valid location.');
}

/**
 * Some nodes need to marked as non-instrumentable; since babel will apply
 * our plugin to nodes we create, we have to be careful to not put ourselves
 * into an infinite loop.
 * @param {Object} node Babel AST node.
 * @returns {Object} Babel AST node that won't be instrumented.
 */
function X(node) {
  node.__adana = true;
  return node;
}

function ignore(path) {
  return !path.node || !path.node.loc || path.node.__adana;
}

function standardize(listener) {
  return function (path, state) {
    return ignore(path) ? undefined : listener(path, state);
  };
}

/**
 * Create the transform-adana babel plugin.
 * @param {Object} types As per `babel`.
 * @returns {Object} `babel` plugin object.
 */
function instrumenter(_ref2) {
  var types = _ref2.types;

  /**
   * Create a chunk of code that marks the specified node as having
   * been executed.
   * @param {Object} state `babel` state for the path that's being walked.
   * @param {Object} options Configure how the marker behaves.
   * @returns {Object} AST node for marking coverage.
   */
  function createMarker(state, options) {
    var tags = options.tags,
        loc = options.loc,
        name = options.name,
        group = options.group;

    var coverage = (0, _meta2.default)(state);
    var id = coverage.entries.length;

    coverage.entries.push({
      id: id,
      loc: loc,
      tags: tags,
      name: name,
      group: group,
      count: 0
    });

    // Maker is simply a statement incrementing a coverage variable.
    return X(types.unaryExpression('++', types.memberExpression(types.memberExpression(coverage.variable, types.numericLiteral(id), true), types.stringLiteral('count'), true)));
  }

  /**
   * [isInstrumentableStatement description]
   * @param   {[type]}  path [description]
   * @returns {Boolean}      [description]
   */
  function isInstrumentableStatement(path) {
    var parent = path.parentPath;
    return !parent.isReturnStatement() && !parent.isVariableDeclaration() && !parent.isExportDeclaration() && !parent.isFunctionDeclaration() && !parent.isIfStatement();
  }

  /**
   * Inject a marker that measures whether the node for the given path has
   * been run or not.
   * @param {Object} path    [description]
   * @param {Object} state   [description]
   * @param {Object} options [description]
   * @returns {void}
   */
  function instrument(path, state, options) {
    // This function is here because isInstrumentableStatement() is being
    // called; we can't create the marker without knowing the result of that,
    // otherwise dead markers will be created.
    function marker() {
      return createMarker(state, _extends({
        loc: path.node.loc
      }, options));
    }

    if (path.isBlockStatement()) {
      path.unshiftContainer('body', X(types.expressionStatement(marker())));
    } else if (path.isExpression()) {
      path.replaceWith(X(types.sequenceExpression([marker(), path.node])));
    } else if (path.isStatement()) {
      if (isInstrumentableStatement(path)) {
        path.insertBefore(X(types.expressionStatement(marker())));
      }
    }
  }

  /**
   * [visitStatement description]
   * @param {[type]} path  [description]
   * @param {[type]} state [description]
   * @returns {void}
   */
  function visitStatement(path, state) {
    instrument(path, state, {
      tags: ['statement', 'line'],
      loc: path.node.loc
    });
  }

  /**
   * The function visitor is mainly to track the definitions of functions;
   * being able ensure how many of your functions have actually been invoked.
   * @param {[type]} path  [description]
   * @param {[type]} state [description]
   * @returns {void}
   */
  function visitFunction(path, state) {
    instrument(path.get('body'), state, {
      tags: ['function'],
      name: path.node.id ? path.node.id.name : '@' + key(path),
      loc: path.node.loc
    });
  }

  /**
   * Multiple branches based on the result of `case _` and `default`. If you
   * do not provide a `default` one will be intelligently added for you,
   * forcing you to cover that case.
   * @param {[type]} path  [description]
   * @param {[type]} state [description]
   * @returns {void}
   */
  function visitSwitchStatement(path, state) {
    var hasDefault = false;
    path.get('cases').forEach(function (entry) {
      if (entry.node.test) {
        (0, _tags.addRules)(state, entry.node.loc, entry.node.test.trailingComments);
      }
      if (entry.node.consequent.length > 1) {
        (0, _tags.addRules)(state, entry.node.loc, entry.node.consequent[0].leadingComments);
      }

      if (entry.node.test === null) {
        hasDefault = true;
      }
      entry.unshiftContainer('consequent', createMarker(state, {
        tags: ['branch', 'switch'],
        loc: entry.node.loc,
        group: key(path)
      }));
    });

    // Default is technically a branch, just like if statements without
    // else's are also technically a branch.
    if (!hasDefault) {
      // Add an extra break to the end of the last case in case some idiot
      // forgot to add it.
      var cases = path.get('cases');
      if (cases.length > 0) {
        cases[cases.length - 1].pushContainer('consequent', types.breakStatement());
      }
      // Finally add the default case.
      path.pushContainer('cases', types.switchCase(null, [types.expressionStatement(createMarker(state, {
        tags: ['branch', 'switch'],
        loc: {
          start: path.node.loc.end,
          end: path.node.loc.end
        },
        group: key(path)
      })), types.breakStatement()]));
    }
  }

  /**
   * [visitVariableDeclaration description]
   * @param {[type]} path  [description]
   * @param {[type]} state [description]
   * @returns {void}
   */
  function visitVariableDeclaration(path, state) {
    path.get('declarations').forEach(function (decl) {
      if (decl.has('init')) {
        instrument(decl.get('init'), state, {
          tags: ['statement', 'variable', 'line']
        });
      }
    });
  }

  /**
   * Includes both while and do-while loops. They contain a single branch which
   * tests the loop condition.
   * @param {[type]} path  [description]
   * @param {[type]} state [description]
   * @returns {void}
   */
  function visitWhileLoop(path, state) {
    var test = path.get('test');
    var group = key(path);
    // This is a particularly clever use of the fact JS operators are short-
    // circuiting. To instrument a loop one _cannot_ add a marker on the outside
    // of the loop body due to weird cases of things where loops are in non-
    // block if statements. So instead, create the following mechanism:
    // ((condition && A) || !B) where A and B are markers. Since markers are
    // postfix, they're always true. Ergo, A is only incremented when condition
    // is true, B only when it's false and the truth value of the whole
    // statement is preserved. Neato.
    test.replaceWith(types.logicalExpression('||', types.logicalExpression('&&', X(test.node), createMarker(state, {
      tags: ['branch', 'line', 'statement', 'loop', 'while'],
      loc: test.node.loc,
      group: group
    })), types.unaryExpression('!', createMarker(state, {
      tags: ['branch', 'line', 'loop', 'while'],
      loc: test.node.loc,
      group: group
    }))));
  }

  /**
   * The try block can either fully succeed (no error) or it can throw. Both
   * cases are accounted for.
   * @param {[type]} path  [description]
   * @param {[type]} state [description]
   * @returns {void}
   */
  function visitTryStatement(path, state) {
    var group = key(path);
    var body = path.get('block');
    var trigger = path.scope.generateDeclaredUidIdentifier('_exception');
    (0, _tags.addRules)(state, body.node.loc, body.node.leadingComments);
    path.get('block').unshiftContainer('body', types.expressionStatement(types.assignmentExpression('=', trigger, types.booleanLiteral(true))));
    var handlerExpression = types.expressionStatement(types.assignmentExpression('=', trigger, types.booleanLiteral(false)));
    var handlerLoc = void 0;
    if (path.has('handler')) {
      var handler = path.get('handler').node;
      handlerLoc = handler.loc;
      (0, _tags.addRules)(state, handler.loc, handler.body.leadingComments);
      path.get('handler.body').unshiftContainer('body', handlerExpression);
    } else {
      var loc = path.get('block').node.loc.end;
      handlerLoc = { start: loc, end: loc };
      path.get('handler').replaceWith(types.catchClause(types.identifier('err'), types.blockStatement([handlerExpression, types.throwStatement(types.identifier('err'))])));
    }

    var guard = types.ifStatement(trigger, types.expressionStatement(createMarker(state, {
      tags: ['branch', 'line', 'exception'],
      loc: path.get('block').node.loc,
      group: group
    })), types.expressionStatement(createMarker(state, {
      tags: ['branch', 'line', 'exception'],
      loc: handlerLoc,
      group: group
    })));

    if (path.has('finalizer')) {
      path.get('finalizer').unshiftContainer('body', guard);
    } else {
      path.get('finalizer').replaceWith(types.blockStatement([guard]));
    }
  }

  /**
   * Return statements are instrumented by marking the next block they return.
   * This helps ensure multi-line expressions for return statements are
   * accurately captured.
   * @param   {[type]} path  [description]
   * @param   {[type]} state [description]
   * @returns {[type]}       [description]
   */
  function visitReturnStatement(path, state) {
    if (!path.has('argument')) {
      path.get('argument').replaceWith(types.sequenceExpression([createMarker(state, {
        loc: path.node.loc,
        tags: ['line', 'statement']
      }), types.identifier('undefined')]));
    } else {
      instrument(path.get('argument'), state, {
        tags: ['line', 'statement']
      });
    }
  }

  /**
   * For multi-line reporting (and objects do tend to span multiple lines) this
   * is required to know which parts of the object where actually executed.
   * Ignore shorthand property that look like `{ this }`.
   * @param   {[type]} path  [description]
   * @param   {[type]} state [description]
   * @returns {[type]}       [description]
   */
  function visitObjectProperty(path, state) {
    if (!path.node.shorthand && !path.parentPath.isPattern()) {
      var _key = path.get('key');
      var value = path.get('value');
      if (path.node.computed) {
        instrument(_key, state, {
          tags: ['line']
        });
      }
      instrument(value, state, {
        tags: ['line']
      });
    }
  }

  /**
   * For multi-line reporting (and arrays do tend to span multiple lines) this
   * is required to know which parts of the array where actually executed.
   * This does _not_ include destructed arrays.
   * @param   {[type]} path  [description]
   * @param   {[type]} state [description]
   * @returns {[type]}       [description]
   */
  function visitArrayExpression(path, state) {
    if (!path.parentPath.isPattern()) {
      path.get('elements').forEach(function (element) {
        instrument(element, state, {
          tags: ['line']
        });
      });
    }
  }

  /**
   * Logical expressions are those using logic operators like `&&` and `||`.
   * Since logic expressions short-circuit in JS they are effectively branches
   * and will be treated as such here.
   * @param {[type]} path  [description]
   * @param {[type]} state [description]
   * @returns {void}
   */
  function visitLogicalExpression(path, state) {
    var group = key(path);
    var test = path.scope.generateDeclaredUidIdentifier('test');

    path.replaceWith(X(types.conditionalExpression(types.assignmentExpression('=', test, X(path.node)), types.sequenceExpression([createMarker(state, {
      tags: ['branch', 'logic'],
      loc: path.get('left').node.loc,
      group: group
    }), test]), types.sequenceExpression([createMarker(state, {
      tags: ['branch', 'logic'],
      loc: path.get('right').node.loc,
      group: group
    }), test]))));
  }

  /**
   * Conditionals are either if/else statements or tenaiary expressions. They
   * have a test case and two choices (based on the test result). Both cases
   * are always accounted for, even if the code does not exist for the alternate
   * case.
   * @param {[type]} path  [description]
   * @param {[type]} state [description]
   * @returns {void}
   */
  function visitConditional(path, state) {
    // Branches can be grouped together so that each of the possible branch
    // destinations is accounted for under one group. For if statements, this
    // refers to all the blocks that fall under a single if.. else if.. else..
    // grouping.
    var root = path.findParent(function (search) {
      return search.node.type === path.node.type && !ignore(search) && (!search.parentPath || search.parentPath.node.type !== path.node.type);
    }) || path;

    // Create the group name based on the root `if` statement.
    var group = key(root);

    function tagBranch(path) {
      (0, _tags.addRules)(state, path.node.loc, path.node.leadingComments);
      if (path.isBlockStatement() && path.node.body.length > 0) {
        (0, _tags.addRules)(state, path.node.loc, path.node.body[0].leadingComments);
      }
    }

    tagBranch(path.get('consequent'));
    if (path.has('alternate')) {
      tagBranch(path.get('alternate'));
    }

    instrument(path.get('consequent'), state, {
      tags: ['branch', 'line', 'if'],
      loc: path.node.consequent.loc,
      group: group
    });

    if (path.has('alternate') && !path.get('alternate').isIfStatement()) {
      instrument(path.get('alternate'), state, {
        tags: ['branch', 'line', 'if'],
        loc: path.node.alternate.loc,
        group: group
      });
    } else if (!path.has('alternate')) {
      path.get('alternate').replaceWith(types.expressionStatement(createMarker(state, {
        tags: ['branch', 'if'],
        loc: {
          start: path.node.loc.end,
          end: path.node.loc.end
        },
        group: group
      })));
    }
  }

  function noInstrument(path) {
    if (path.node && path.node.leadingComments && path.node.leadingComments.some(function (comment) {
      return (/^\s*adana-no-instrument\s*$/.exec(comment.value)
      );
    })) {
      path.skip();
      return;
    }
  }

  var visitor = {
    // Expressions
    ArrowFunctionExpression: visitFunction,
    FunctionExpression: visitFunction,
    ObjectMethod: visitFunction,
    ClassMethod: visitFunction,
    LogicalExpression: visitLogicalExpression,
    ConditionalExpression: visitConditional,
    ObjectProperty: visitObjectProperty,
    ArrayExpression: visitArrayExpression,

    // Declarations
    FunctionDeclaration: visitFunction,
    VariableDeclaration: visitVariableDeclaration,

    // Statements
    ContinueStatement: visitStatement,
    BreakStatement: visitStatement,
    ExpressionStatement: visitStatement,
    ThrowStatement: visitStatement,
    ReturnStatement: visitReturnStatement,
    TryStatement: visitTryStatement,
    WhileStatement: visitWhileLoop,
    DoWhileStatement: visitWhileLoop,
    IfStatement: visitConditional,
    SwitchStatement: visitSwitchStatement,

    // Generics
    enter: noInstrument
  };

  Object.keys(visitor).forEach(function (key) {
    visitor[key] = standardize(visitor[key]);
  });

  // Create the actual babel plugin object.
  return {
    visitor: {
      Program: function Program(path, state) {
        // Check if file should be instrumented or not.
        if (skip(state)) {
          return;
        }
        (0, _meta2.default)(state, {
          source: state.file.code,
          entries: [],
          rules: [],
          tags: {},
          variable: path.scope.generateUidIdentifier('coverage')
        });
        path.traverse(visitor, state);
        (0, _tags.applyRules)(state);
        path.unshiftContainer('body', (0, _prelude2.default)(state));
      }
    }
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbnN0cnVtZW50ZXIuanMiXSwibmFtZXMiOlsic2tpcCIsImtleSIsImluc3RydW1lbnRlciIsIm9wdHMiLCJmaWxlIiwiaWdub3JlIiwib25seSIsInNob3VsZElnbm9yZSIsImZpbGVuYW1lIiwiYXJyYXlpZnkiLCJyZWdleGlmeSIsInBhdGgiLCJub2RlIiwibG9jIiwibG9jYXRpb24iLCJzdGFydCIsImxpbmUiLCJjb2x1bW4iLCJUeXBlRXJyb3IiLCJYIiwiX19hZGFuYSIsInN0YW5kYXJkaXplIiwibGlzdGVuZXIiLCJzdGF0ZSIsInVuZGVmaW5lZCIsInR5cGVzIiwiY3JlYXRlTWFya2VyIiwib3B0aW9ucyIsInRhZ3MiLCJuYW1lIiwiZ3JvdXAiLCJjb3ZlcmFnZSIsImlkIiwiZW50cmllcyIsImxlbmd0aCIsInB1c2giLCJjb3VudCIsInVuYXJ5RXhwcmVzc2lvbiIsIm1lbWJlckV4cHJlc3Npb24iLCJ2YXJpYWJsZSIsIm51bWVyaWNMaXRlcmFsIiwic3RyaW5nTGl0ZXJhbCIsImlzSW5zdHJ1bWVudGFibGVTdGF0ZW1lbnQiLCJwYXJlbnQiLCJwYXJlbnRQYXRoIiwiaXNSZXR1cm5TdGF0ZW1lbnQiLCJpc1ZhcmlhYmxlRGVjbGFyYXRpb24iLCJpc0V4cG9ydERlY2xhcmF0aW9uIiwiaXNGdW5jdGlvbkRlY2xhcmF0aW9uIiwiaXNJZlN0YXRlbWVudCIsImluc3RydW1lbnQiLCJtYXJrZXIiLCJpc0Jsb2NrU3RhdGVtZW50IiwidW5zaGlmdENvbnRhaW5lciIsImV4cHJlc3Npb25TdGF0ZW1lbnQiLCJpc0V4cHJlc3Npb24iLCJyZXBsYWNlV2l0aCIsInNlcXVlbmNlRXhwcmVzc2lvbiIsImlzU3RhdGVtZW50IiwiaW5zZXJ0QmVmb3JlIiwidmlzaXRTdGF0ZW1lbnQiLCJ2aXNpdEZ1bmN0aW9uIiwiZ2V0IiwidmlzaXRTd2l0Y2hTdGF0ZW1lbnQiLCJoYXNEZWZhdWx0IiwiZm9yRWFjaCIsImVudHJ5IiwidGVzdCIsInRyYWlsaW5nQ29tbWVudHMiLCJjb25zZXF1ZW50IiwibGVhZGluZ0NvbW1lbnRzIiwiY2FzZXMiLCJwdXNoQ29udGFpbmVyIiwiYnJlYWtTdGF0ZW1lbnQiLCJzd2l0Y2hDYXNlIiwiZW5kIiwidmlzaXRWYXJpYWJsZURlY2xhcmF0aW9uIiwiZGVjbCIsImhhcyIsInZpc2l0V2hpbGVMb29wIiwibG9naWNhbEV4cHJlc3Npb24iLCJ2aXNpdFRyeVN0YXRlbWVudCIsImJvZHkiLCJ0cmlnZ2VyIiwic2NvcGUiLCJnZW5lcmF0ZURlY2xhcmVkVWlkSWRlbnRpZmllciIsImFzc2lnbm1lbnRFeHByZXNzaW9uIiwiYm9vbGVhbkxpdGVyYWwiLCJoYW5kbGVyRXhwcmVzc2lvbiIsImhhbmRsZXJMb2MiLCJoYW5kbGVyIiwiY2F0Y2hDbGF1c2UiLCJpZGVudGlmaWVyIiwiYmxvY2tTdGF0ZW1lbnQiLCJ0aHJvd1N0YXRlbWVudCIsImd1YXJkIiwiaWZTdGF0ZW1lbnQiLCJ2aXNpdFJldHVyblN0YXRlbWVudCIsInZpc2l0T2JqZWN0UHJvcGVydHkiLCJzaG9ydGhhbmQiLCJpc1BhdHRlcm4iLCJ2YWx1ZSIsImNvbXB1dGVkIiwidmlzaXRBcnJheUV4cHJlc3Npb24iLCJlbGVtZW50IiwidmlzaXRMb2dpY2FsRXhwcmVzc2lvbiIsImNvbmRpdGlvbmFsRXhwcmVzc2lvbiIsInZpc2l0Q29uZGl0aW9uYWwiLCJyb290IiwiZmluZFBhcmVudCIsInNlYXJjaCIsInR5cGUiLCJ0YWdCcmFuY2giLCJhbHRlcm5hdGUiLCJub0luc3RydW1lbnQiLCJzb21lIiwiY29tbWVudCIsImV4ZWMiLCJ2aXNpdG9yIiwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24iLCJGdW5jdGlvbkV4cHJlc3Npb24iLCJPYmplY3RNZXRob2QiLCJDbGFzc01ldGhvZCIsIkxvZ2ljYWxFeHByZXNzaW9uIiwiQ29uZGl0aW9uYWxFeHByZXNzaW9uIiwiT2JqZWN0UHJvcGVydHkiLCJBcnJheUV4cHJlc3Npb24iLCJGdW5jdGlvbkRlY2xhcmF0aW9uIiwiVmFyaWFibGVEZWNsYXJhdGlvbiIsIkNvbnRpbnVlU3RhdGVtZW50IiwiQnJlYWtTdGF0ZW1lbnQiLCJFeHByZXNzaW9uU3RhdGVtZW50IiwiVGhyb3dTdGF0ZW1lbnQiLCJSZXR1cm5TdGF0ZW1lbnQiLCJUcnlTdGF0ZW1lbnQiLCJXaGlsZVN0YXRlbWVudCIsIkRvV2hpbGVTdGF0ZW1lbnQiLCJJZlN0YXRlbWVudCIsIlN3aXRjaFN0YXRlbWVudCIsImVudGVyIiwiT2JqZWN0Iiwia2V5cyIsIlByb2dyYW0iLCJzb3VyY2UiLCJjb2RlIiwicnVsZXMiLCJnZW5lcmF0ZVVpZElkZW50aWZpZXIiLCJ0cmF2ZXJzZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7UUFLZ0JBLEksR0FBQUEsSTtRQWtCQUMsRyxHQUFBQSxHO2tCQWtDUUMsWTs7QUF6RHhCOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVPLFNBQVNGLElBQVQsR0FBa0M7QUFBQSxpRkFBTCxFQUFLO0FBQUEsTUFBbkJHLElBQW1CLFFBQW5CQSxJQUFtQjtBQUFBLE1BQWJDLElBQWEsUUFBYkEsSUFBYTs7QUFDdkMsTUFBSUEsUUFBUUQsSUFBWixFQUFrQjtBQUFBLHVCQUNZQSxJQURaLENBQ1RFLE1BRFM7QUFBQSxRQUNUQSxPQURTLGdDQUNBLEVBREE7QUFBQSxRQUNJQyxJQURKLEdBQ1lILElBRFosQ0FDSUcsSUFESjs7QUFFaEIsV0FBTyxnQkFBS0MsWUFBTCxDQUNMSCxLQUFLRCxJQUFMLENBQVVLLFFBREwsRUFFTCxnQkFBS0MsUUFBTCxDQUFjSixPQUFkLEVBQXNCLGdCQUFLSyxRQUEzQixDQUZLLEVBR0xKLE9BQU8sZ0JBQUtHLFFBQUwsQ0FBY0gsSUFBZCxFQUFvQixnQkFBS0ksUUFBekIsQ0FBUCxHQUE0QyxJQUh2QyxDQUFQO0FBS0Q7QUFDRCxTQUFPLEtBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTU8sU0FBU1QsR0FBVCxDQUFhVSxJQUFiLEVBQW1CO0FBQ3hCLE1BQU1DLE9BQU9ELEtBQUtDLElBQWxCO0FBQ0EsTUFBSUEsS0FB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c0Usb0JBQWdCdEUsY0FqQkY7QUFrQmR1RSx5QkFBcUJ2RSxjQWxCUDtBQW1CZHdFLG9CQUFnQnhFLGNBbkJGO0FBb0JkeUUscUJBQWlCcEMsb0JBcEJIO0FBcUJkcUMsa0JBQWNyRCxpQkFyQkE7QUFzQmRzRCxvQkFBZ0J4RCxjQXRCRjtBQXVCZHlELHNCQUFrQnpELGNBdkJKO0FBd0JkMEQsaUJBQWE5QixnQkF4QkM7QUF5QmQrQixxQkFBaUIzRSxvQkF6Qkg7O0FBMkJkO0FBQ0E0RSxXQUFPekI7QUE1Qk8sR0FBaEI7O0FBK0JBMEIsU0FBT0MsSUFBUCxDQUFZdkIsT0FBWixFQUFxQnJELE9BQXJCLENBQTZCLFVBQUNoRSxHQUFELEVBQVM7QUFDcENxSCxZQUFRckgsR0FBUixJQUFlb0IsWUFBWWlHLFFBQVFySCxHQUFSLENBQVosQ0FBZjtBQUNELEdBRkQ7O0FBSUE7QUFDQSxTQUFPO0FBQ0xxSCxhQUFTO0FBQ1B3QixhQURPLG1CQUNDbkksSUFERCxFQUNPWSxLQURQLEVBQ2M7QUFDbkI7QUFDQSxZQUFJdkIsS0FBS3VCLEtBQUwsQ0FBSixFQUFpQjtBQUNmO0FBQ0Q7QUFDRCw0QkFBS0EsS0FBTCxFQUFZO0FBQ1Z3SCxrQkFBUXhILE1BQU1uQixJQUFOLENBQVc0SSxJQURUO0FBRVYvRyxtQkFBUyxFQUZDO0FBR1ZnSCxpQkFBTyxFQUhHO0FBSVZySCxnQkFBTSxFQUpJO0FBS1ZXLG9CQUFVNUIsS0FBS3lFLEtBQUwsQ0FBVzhELHFCQUFYLENBQWlDLFVBQWpDO0FBTEEsU0FBWjtBQU9BdkksYUFBS3dJLFFBQUwsQ0FBYzdCLE9BQWQsRUFBdUIvRixLQUF2QjtBQUNBLDhCQUFXQSxLQUFYO0FBQ0FaLGFBQUswQyxnQkFBTCxDQUFzQixNQUF0QixFQUE4Qix1QkFBUTlCLEtBQVIsQ0FBOUI7QUFDRDtBQWhCTTtBQURKLEdBQVA7QUFvQkQiLCJmaWxlIjoiaW5zdHJ1bWVudGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1dGlsfSBmcm9tICdiYWJlbC1jb3JlJztcbmltcG9ydCBwcmVsdWRlIGZyb20gJy4vcHJlbHVkZSc7XG5pbXBvcnQgbWV0YSBmcm9tICcuL21ldGEnO1xuaW1wb3J0IHthcHBseVJ1bGVzLCBhZGRSdWxlc30gZnJvbSAnLi90YWdzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNraXAoe29wdHMsIGZpbGV9ID0geyB9KSB7XG4gIGlmIChmaWxlICYmIG9wdHMpIHtcbiAgICBjb25zdCB7aWdub3JlID0gW10sIG9ubHl9ID0gb3B0cztcbiAgICByZXR1cm4gdXRpbC5zaG91bGRJZ25vcmUoXG4gICAgICBmaWxlLm9wdHMuZmlsZW5hbWUsXG4gICAgICB1dGlsLmFycmF5aWZ5KGlnbm9yZSwgdXRpbC5yZWdleGlmeSksXG4gICAgICBvbmx5ID8gdXRpbC5hcnJheWlmeShvbmx5LCB1dGlsLnJlZ2V4aWZ5KSA6IG51bGxcbiAgICApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gb3BhcXVlLCB1bmlxdWUga2V5IGZvciBhIGdpdmVuIG5vZGUuIFVzZWZ1bCBmb3IgdGFnZ2luZyB0aGUgbm9kZVxuICogaW4gc2VwYXJhdGUgcGxhY2VzLlxuICogQHBhcmFtIHtPYmplY3R9IHBhdGggQmFiZWwgcGF0aCB0byBkZXJpdmUga2V5IGZyb20uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBTdHJpbmcga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24ga2V5KHBhdGgpIHtcbiAgY29uc3Qgbm9kZSA9IHBhdGgubm9kZTtcbiAgaWYgKG5vZGUubG9jKSB7XG4gICAgY29uc3QgbG9jYXRpb24gPSBub2RlLmxvYy5zdGFydDtcbiAgICByZXR1cm4gYCR7bG9jYXRpb24ubGluZX06JHtsb2NhdGlvbi5jb2x1bW59YDtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXRoIG11c3QgaGF2ZSB2YWxpZCBsb2NhdGlvbi4nKTtcbn1cblxuLyoqXG4gKiBTb21lIG5vZGVzIG5lZWQgdG8gbWFya2VkIGFzIG5vbi1pbnN0cnVtZW50YWJsZTsgc2luY2UgYmFiZWwgd2lsbCBhcHBseVxuICogb3VyIHBsdWdpbiB0byBub2RlcyB3ZSBjcmVhdGUsIHdlIGhhdmUgdG8gYmUgY2FyZWZ1bCB0byBub3QgcHV0IG91cnNlbHZlc1xuICogaW50byBhbiBpbmZpbml0ZSBsb29wLlxuICogQHBhcmFtIHtPYmplY3R9IG5vZGUgQmFiZWwgQVNUIG5vZGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBCYWJlbCBBU1Qgbm9kZSB0aGF0IHdvbid0IGJlIGluc3RydW1lbnRlZC5cbiAqL1xuZnVuY3Rpb24gWChub2RlKSB7XG4gIG5vZGUuX19hZGFuYSA9IHRydWU7XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBpZ25vcmUocGF0aCkge1xuICByZXR1cm4gKCFwYXRoLm5vZGUgfHwgIXBhdGgubm9kZS5sb2MgfHwgcGF0aC5ub2RlLl9fYWRhbmEpO1xufVxuXG5mdW5jdGlvbiBzdGFuZGFyZGl6ZShsaXN0ZW5lcikge1xuICByZXR1cm4gKHBhdGgsIHN0YXRlKSA9PiBpZ25vcmUocGF0aCkgPyB1bmRlZmluZWQgOiBsaXN0ZW5lcihwYXRoLCBzdGF0ZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSB0cmFuc2Zvcm0tYWRhbmEgYmFiZWwgcGx1Z2luLlxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIEFzIHBlciBgYmFiZWxgLlxuICogQHJldHVybnMge09iamVjdH0gYGJhYmVsYCBwbHVnaW4gb2JqZWN0LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbnN0cnVtZW50ZXIoe3R5cGVzfSkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgY2h1bmsgb2YgY29kZSB0aGF0IG1hcmtzIHRoZSBzcGVjaWZpZWQgbm9kZSBhcyBoYXZpbmdcbiAgICogYmVlbiBleGVjdXRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGBiYWJlbGAgc3RhdGUgZm9yIHRoZSBwYXRoIHRoYXQncyBiZWluZyB3YWxrZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbmZpZ3VyZSBob3cgdGhlIG1hcmtlciBiZWhhdmVzLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBU1Qgbm9kZSBmb3IgbWFya2luZyBjb3ZlcmFnZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZU1hcmtlcihzdGF0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHt0YWdzLCBsb2MsIG5hbWUsIGdyb3VwfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY292ZXJhZ2UgPSBtZXRhKHN0YXRlKTtcbiAgICBjb25zdCBpZCA9IGNvdmVyYWdlLmVudHJpZXMubGVuZ3RoO1xuXG4gICAgY292ZXJhZ2UuZW50cmllcy5wdXNoKHtcbiAgICAgIGlkLFxuICAgICAgbG9jLFxuICAgICAgdGFncyxcbiAgICAgIG5hbWUsXG4gICAgICBncm91cCxcbiAgICAgIGNvdW50OiAwLFxuICAgIH0pO1xuXG4gICAgLy8gTWFrZXIgaXMgc2ltcGx5IGEgc3RhdGVtZW50IGluY3JlbWVudGluZyBhIGNvdmVyYWdlIHZhcmlhYmxlLlxuICAgIHJldHVybiBYKHR5cGVzLnVuYXJ5RXhwcmVzc2lvbignKysnLCB0eXBlcy5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgdHlwZXMubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgY292ZXJhZ2UudmFyaWFibGUsXG4gICAgICAgIHR5cGVzLm51bWVyaWNMaXRlcmFsKGlkKSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKSxcbiAgICAgIHR5cGVzLnN0cmluZ0xpdGVyYWwoJ2NvdW50JyksXG4gICAgICB0cnVlXG4gICAgKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFtpc0luc3RydW1lbnRhYmxlU3RhdGVtZW50IGRlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gICB7W3R5cGVdfSAgcGF0aCBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIGZ1bmN0aW9uIGlzSW5zdHJ1bWVudGFibGVTdGF0ZW1lbnQocGF0aCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHBhdGgucGFyZW50UGF0aDtcbiAgICByZXR1cm4gIXBhcmVudC5pc1JldHVyblN0YXRlbWVudCgpICYmXG4gICAgICAhcGFyZW50LmlzVmFyaWFibGVEZWNsYXJhdGlvbigpICYmXG4gICAgICAhcGFyZW50LmlzRXhwb3J0RGVjbGFyYXRpb24oKSAmJlxuICAgICAgIXBhcmVudC5pc0Z1bmN0aW9uRGVjbGFyYXRpb24oKSAmJlxuICAgICAgIXBhcmVudC5pc0lmU3RhdGVtZW50KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5qZWN0IGEgbWFya2VyIHRoYXQgbWVhc3VyZXMgd2hldGhlciB0aGUgbm9kZSBmb3IgdGhlIGdpdmVuIHBhdGggaGFzXG4gICAqIGJlZW4gcnVuIG9yIG5vdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhdGggICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiBpbnN0cnVtZW50KHBhdGgsIHN0YXRlLCBvcHRpb25zKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBoZXJlIGJlY2F1c2UgaXNJbnN0cnVtZW50YWJsZVN0YXRlbWVudCgpIGlzIGJlaW5nXG4gICAgLy8gY2FsbGVkOyB3ZSBjYW4ndCBjcmVhdGUgdGhlIG1hcmtlciB3aXRob3V0IGtub3dpbmcgdGhlIHJlc3VsdCBvZiB0aGF0LFxuICAgIC8vIG90aGVyd2lzZSBkZWFkIG1hcmtlcnMgd2lsbCBiZSBjcmVhdGVkLlxuICAgIGZ1bmN0aW9uIG1hcmtlcigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVNYXJrZXIoc3RhdGUsIHtcbiAgICAgICAgbG9jOiBwYXRoLm5vZGUubG9jLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGguaXNCbG9ja1N0YXRlbWVudCgpKSB7XG4gICAgICBwYXRoLnVuc2hpZnRDb250YWluZXIoJ2JvZHknLCBYKHR5cGVzLmV4cHJlc3Npb25TdGF0ZW1lbnQobWFya2VyKCkpKSk7XG4gICAgfSBlbHNlIGlmIChwYXRoLmlzRXhwcmVzc2lvbigpKSB7XG4gICAgICBwYXRoLnJlcGxhY2VXaXRoKFgodHlwZXMuc2VxdWVuY2VFeHByZXNzaW9uKFttYXJrZXIoKSwgcGF0aC5ub2RlXSkpKTtcbiAgICB9IGVsc2UgaWYgKHBhdGguaXNTdGF0ZW1lbnQoKSkge1xuICAgICAgaWYgKGlzSW5zdHJ1bWVudGFibGVTdGF0ZW1lbnQocGF0aCkpIHtcbiAgICAgICAgcGF0aC5pbnNlcnRCZWZvcmUoWCh0eXBlcy5leHByZXNzaW9uU3RhdGVtZW50KG1hcmtlcigpKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBbdmlzaXRTdGF0ZW1lbnQgZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSB7W3R5cGVdfSBwYXRoICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSB7W3R5cGVdfSBzdGF0ZSBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24gdmlzaXRTdGF0ZW1lbnQocGF0aCwgc3RhdGUpIHtcbiAgICBpbnN0cnVtZW50KHBhdGgsIHN0YXRlLCB7XG4gICAgICB0YWdzOiBbJ3N0YXRlbWVudCcsICdsaW5lJ10sXG4gICAgICBsb2M6IHBhdGgubm9kZS5sb2MsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIHZpc2l0b3IgaXMgbWFpbmx5IHRvIHRyYWNrIHRoZSBkZWZpbml0aW9ucyBvZiBmdW5jdGlvbnM7XG4gICAqIGJlaW5nIGFibGUgZW5zdXJlIGhvdyBtYW55IG9mIHlvdXIgZnVuY3Rpb25zIGhhdmUgYWN0dWFsbHkgYmVlbiBpbnZva2VkLlxuICAgKiBAcGFyYW0ge1t0eXBlXX0gcGF0aCAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0ge1t0eXBlXX0gc3RhdGUgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHZpc2l0RnVuY3Rpb24ocGF0aCwgc3RhdGUpIHtcbiAgICBpbnN0cnVtZW50KHBhdGguZ2V0KCdib2R5JyksIHN0YXRlLCB7XG4gICAgICB0YWdzOiBbJ2Z1bmN0aW9uJ10sXG4gICAgICBuYW1lOiBwYXRoLm5vZGUuaWQgPyBwYXRoLm5vZGUuaWQubmFtZSA6IGBAJHtrZXkocGF0aCl9YCxcbiAgICAgIGxvYzogcGF0aC5ub2RlLmxvYyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBsZSBicmFuY2hlcyBiYXNlZCBvbiB0aGUgcmVzdWx0IG9mIGBjYXNlIF9gIGFuZCBgZGVmYXVsdGAuIElmIHlvdVxuICAgKiBkbyBub3QgcHJvdmlkZSBhIGBkZWZhdWx0YCBvbmUgd2lsbCBiZSBpbnRlbGxpZ2VudGx5IGFkZGVkIGZvciB5b3UsXG4gICAqIGZvcmNpbmcgeW91IHRvIGNvdmVyIHRoYXQgY2FzZS5cbiAgICogQHBhcmFtIHtbdHlwZV19IHBhdGggIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtIHtbdHlwZV19IHN0YXRlIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiB2aXNpdFN3aXRjaFN0YXRlbWVudChwYXRoLCBzdGF0ZSkge1xuICAgIGxldCBoYXNEZWZhdWx0ID0gZmFsc2U7XG4gICAgcGF0aC5nZXQoJ2Nhc2VzJykuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgIGlmIChlbnRyeS5ub2RlLnRlc3QpIHtcbiAgICAgICAgYWRkUnVsZXMoc3RhdGUsIGVudHJ5Lm5vZGUubG9jLCBlbnRyeS5ub2RlLnRlc3QudHJhaWxpbmdDb21tZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAoZW50cnkubm9kZS5jb25zZXF1ZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgYWRkUnVsZXMoXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgZW50cnkubm9kZS5sb2MsXG4gICAgICAgICAgZW50cnkubm9kZS5jb25zZXF1ZW50WzBdLmxlYWRpbmdDb21tZW50c1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW50cnkubm9kZS50ZXN0ID09PSBudWxsKSB7XG4gICAgICAgIGhhc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZW50cnkudW5zaGlmdENvbnRhaW5lcignY29uc2VxdWVudCcsIGNyZWF0ZU1hcmtlcihzdGF0ZSwge1xuICAgICAgICB0YWdzOiBbJ2JyYW5jaCcsICdzd2l0Y2gnXSxcbiAgICAgICAgbG9jOiBlbnRyeS5ub2RlLmxvYyxcbiAgICAgICAgZ3JvdXA6IGtleShwYXRoKSxcbiAgICAgIH0pKTtcbiAgICB9KTtcblxuICAgIC8vIERlZmF1bHQgaXMgdGVjaG5pY2FsbHkgYSBicmFuY2gsIGp1c3QgbGlrZSBpZiBzdGF0ZW1lbnRzIHdpdGhvdXRcbiAgICAvLyBlbHNlJ3MgYXJlIGFsc28gdGVjaG5pY2FsbHkgYSBicmFuY2guXG4gICAgaWYgKCFoYXNEZWZhdWx0KSB7XG4gICAgICAvLyBBZGQgYW4gZXh0cmEgYnJlYWsgdG8gdGhlIGVuZCBvZiB0aGUgbGFzdCBjYXNlIGluIGNhc2Ugc29tZSBpZGlvdFxuICAgICAgLy8gZm9yZ290IHRvIGFkZCBpdC5cbiAgICAgIGNvbnN0IGNhc2VzID0gcGF0aC5nZXQoJ2Nhc2VzJyk7XG4gICAgICBpZiAoY2FzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjYXNlc1tjYXNlcy5sZW5ndGggLSAxXS5wdXNoQ29udGFpbmVyKFxuICAgICAgICAgICdjb25zZXF1ZW50JyxcbiAgICAgICAgICB0eXBlcy5icmVha1N0YXRlbWVudCgpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyBGaW5hbGx5IGFkZCB0aGUgZGVmYXVsdCBjYXNlLlxuICAgICAgcGF0aC5wdXNoQ29udGFpbmVyKCdjYXNlcycsIHR5cGVzLnN3aXRjaENhc2UobnVsbCwgW1xuICAgICAgICB0eXBlcy5leHByZXNzaW9uU3RhdGVtZW50KGNyZWF0ZU1hcmtlcihzdGF0ZSwge1xuICAgICAgICAgIHRhZ3M6IFsnYnJhbmNoJywgJ3N3aXRjaCddLFxuICAgICAgICAgIGxvYzoge1xuICAgICAgICAgICAgc3RhcnQ6IHBhdGgubm9kZS5sb2MuZW5kLFxuICAgICAgICAgICAgZW5kOiBwYXRoLm5vZGUubG9jLmVuZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdyb3VwOiBrZXkocGF0aCksXG4gICAgICAgIH0pKSxcbiAgICAgICAgdHlwZXMuYnJlYWtTdGF0ZW1lbnQoKSxcbiAgICAgIF0pKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogW3Zpc2l0VmFyaWFibGVEZWNsYXJhdGlvbiBkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtIHtbdHlwZV19IHBhdGggIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtIHtbdHlwZV19IHN0YXRlIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiB2aXNpdFZhcmlhYmxlRGVjbGFyYXRpb24ocGF0aCwgc3RhdGUpIHtcbiAgICBwYXRoLmdldCgnZGVjbGFyYXRpb25zJykuZm9yRWFjaCgoZGVjbCkgPT4ge1xuICAgICAgaWYgKGRlY2wuaGFzKCdpbml0JykpIHtcbiAgICAgICAgaW5zdHJ1bWVudChkZWNsLmdldCgnaW5pdCcpLCBzdGF0ZSwge1xuICAgICAgICAgIHRhZ3M6IFsnc3RhdGVtZW50JywgJ3ZhcmlhYmxlJywgJ2xpbmUnXSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5jbHVkZXMgYm90aCB3aGlsZSBhbmQgZG8td2hpbGUgbG9vcHMuIFRoZXkgY29udGFpbiBhIHNpbmdsZSBicmFuY2ggd2hpY2hcbiAgICogdGVzdHMgdGhlIGxvb3AgY29uZGl0aW9uLlxuICAgKiBAcGFyYW0ge1t0eXBlXX0gcGF0aCAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0ge1t0eXBlXX0gc3RhdGUgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHZpc2l0V2hpbGVMb29wKHBhdGgsIHN0YXRlKSB7XG4gICAgY29uc3QgdGVzdCA9IHBhdGguZ2V0KCd0ZXN0Jyk7XG4gICAgY29uc3QgZ3JvdXAgPSBrZXkocGF0aCk7XG4gICAgLy8gVGhpcyBpcyBhIHBhcnRpY3VsYXJseSBjbGV2ZXIgdXNlIG9mIHRoZSBmYWN0IEpTIG9wZXJhdG9ycyBhcmUgc2hvcnQtXG4gICAgLy8gY2lyY3VpdGluZy4gVG8gaW5zdHJ1bWVudCBhIGxvb3Agb25lIF9jYW5ub3RfIGFkZCBhIG1hcmtlciBvbiB0aGUgb3V0c2lkZVxuICAgIC8vIG9mIHRoZSBsb29wIGJvZHkgZHVlIHRvIHdlaXJkIGNhc2VzIG9mIHRoaW5ncyB3aGVyZSBsb29wcyBhcmUgaW4gbm9uLVxuICAgIC8vIGJsb2NrIGlmIHN0YXRlbWVudHMuIFNvIGluc3RlYWQsIGNyZWF0ZSB0aGUgZm9sbG93aW5nIG1lY2hhbmlzbTpcbiAgICAvLyAoKGNvbmRpdGlvbiAmJiBBKSB8fCAhQikgd2hlcmUgQSBhbmQgQiBhcmUgbWFya2Vycy4gU2luY2UgbWFya2VycyBhcmVcbiAgICAvLyBwb3N0Zml4LCB0aGV5J3JlIGFsd2F5cyB0cnVlLiBFcmdvLCBBIGlzIG9ubHkgaW5jcmVtZW50ZWQgd2hlbiBjb25kaXRpb25cbiAgICAvLyBpcyB0cnVlLCBCIG9ubHkgd2hlbiBpdCdzIGZhbHNlIGFuZCB0aGUgdHJ1dGggdmFsdWUgb2YgdGhlIHdob2xlXG4gICAgLy8gc3RhdGVtZW50IGlzIHByZXNlcnZlZC4gTmVhdG8uXG4gICAgdGVzdC5yZXBsYWNlV2l0aCh0eXBlcy5sb2dpY2FsRXhwcmVzc2lvbihcbiAgICAgICd8fCcsXG4gICAgICB0eXBlcy5sb2dpY2FsRXhwcmVzc2lvbihcbiAgICAgICAgJyYmJyxcbiAgICAgICAgWCh0ZXN0Lm5vZGUpLFxuICAgICAgICBjcmVhdGVNYXJrZXIoc3RhdGUsIHtcbiAgICAgICAgICB0YWdzOiBbJ2JyYW5jaCcsICdsaW5lJywgJ3N0YXRlbWVudCcsICdsb29wJywgJ3doaWxlJ10sXG4gICAgICAgICAgbG9jOiB0ZXN0Lm5vZGUubG9jLFxuICAgICAgICAgIGdyb3VwLFxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIHR5cGVzLnVuYXJ5RXhwcmVzc2lvbihcbiAgICAgICAgJyEnLFxuICAgICAgICBjcmVhdGVNYXJrZXIoc3RhdGUsIHtcbiAgICAgICAgICB0YWdzOiBbJ2JyYW5jaCcsICdsaW5lJywgJ2xvb3AnLCAnd2hpbGUnXSxcbiAgICAgICAgICBsb2M6IHRlc3Qubm9kZS5sb2MsXG4gICAgICAgICAgZ3JvdXAsXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRyeSBibG9jayBjYW4gZWl0aGVyIGZ1bGx5IHN1Y2NlZWQgKG5vIGVycm9yKSBvciBpdCBjYW4gdGhyb3cuIEJvdGhcbiAgICogY2FzZXMgYXJlIGFjY291bnRlZCBmb3IuXG4gICAqIEBwYXJhbSB7W3R5cGVdfSBwYXRoICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSB7W3R5cGVdfSBzdGF0ZSBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24gdmlzaXRUcnlTdGF0ZW1lbnQocGF0aCwgc3RhdGUpIHtcbiAgICBjb25zdCBncm91cCA9IGtleShwYXRoKTtcbiAgICBjb25zdCBib2R5ID0gcGF0aC5nZXQoJ2Jsb2NrJyk7XG4gICAgY29uc3QgdHJpZ2dlciA9IHBhdGguc2NvcGUuZ2VuZXJhdGVEZWNsYXJlZFVpZElkZW50aWZpZXIoJ19leGNlcHRpb24nKTtcbiAgICBhZGRSdWxlcyhzdGF0ZSwgYm9keS5ub2RlLmxvYywgYm9keS5ub2RlLmxlYWRpbmdDb21tZW50cyk7XG4gICAgcGF0aC5nZXQoJ2Jsb2NrJykudW5zaGlmdENvbnRhaW5lcignYm9keScsIHR5cGVzLmV4cHJlc3Npb25TdGF0ZW1lbnQoXG4gICAgICB0eXBlcy5hc3NpZ25tZW50RXhwcmVzc2lvbignPScsIHRyaWdnZXIsIHR5cGVzLmJvb2xlYW5MaXRlcmFsKHRydWUpKSxcbiAgICApKTtcbiAgICBjb25zdCBoYW5kbGVyRXhwcmVzc2lvbiA9IHR5cGVzLmV4cHJlc3Npb25TdGF0ZW1lbnQoXG4gICAgICB0eXBlcy5hc3NpZ25tZW50RXhwcmVzc2lvbignPScsIHRyaWdnZXIsIHR5cGVzLmJvb2xlYW5MaXRlcmFsKGZhbHNlKSksXG4gICAgKTtcbiAgICBsZXQgaGFuZGxlckxvYztcbiAgICBpZiAocGF0aC5oYXMoJ2hhbmRsZXInKSkge1xuICAgICAgY29uc3QgaGFuZGxlciA9IHBhdGguZ2V0KCdoYW5kbGVyJykubm9kZTtcbiAgICAgIGhhbmRsZXJMb2MgPSBoYW5kbGVyLmxvYztcbiAgICAgIGFkZFJ1bGVzKHN0YXRlLCBoYW5kbGVyLmxvYywgaGFuZGxlci5ib2R5LmxlYWRpbmdDb21tZW50cyk7XG4gICAgICBwYXRoLmdldCgnaGFuZGxlci5ib2R5JykudW5zaGlmdENvbnRhaW5lcihcbiAgICAgICAgJ2JvZHknLFxuICAgICAgICBoYW5kbGVyRXhwcmVzc2lvblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbG9jID0gcGF0aC5nZXQoJ2Jsb2NrJykubm9kZS5sb2MuZW5kO1xuICAgICAgaGFuZGxlckxvYyA9IHtzdGFydDogbG9jLCBlbmQ6IGxvY307XG4gICAgICBwYXRoLmdldCgnaGFuZGxlcicpLnJlcGxhY2VXaXRoKHR5cGVzLmNhdGNoQ2xhdXNlKFxuICAgICAgICB0eXBlcy5pZGVudGlmaWVyKCdlcnInKSwgdHlwZXMuYmxvY2tTdGF0ZW1lbnQoW1xuICAgICAgICAgIGhhbmRsZXJFeHByZXNzaW9uLFxuICAgICAgICAgIHR5cGVzLnRocm93U3RhdGVtZW50KFxuICAgICAgICAgICAgdHlwZXMuaWRlbnRpZmllcignZXJyJylcbiAgICAgICAgICApLFxuICAgICAgICBdKVxuICAgICAgKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZ3VhcmQgPSB0eXBlcy5pZlN0YXRlbWVudChcbiAgICAgIHRyaWdnZXIsXG4gICAgICB0eXBlcy5leHByZXNzaW9uU3RhdGVtZW50KFxuICAgICAgICBjcmVhdGVNYXJrZXIoc3RhdGUsIHtcbiAgICAgICAgICB0YWdzOiBbJ2JyYW5jaCcsICdsaW5lJywgJ2V4Y2VwdGlvbiddLFxuICAgICAgICAgIGxvYzogcGF0aC5nZXQoJ2Jsb2NrJykubm9kZS5sb2MsXG4gICAgICAgICAgZ3JvdXAsXG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgdHlwZXMuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgICAgY3JlYXRlTWFya2VyKHN0YXRlLCB7XG4gICAgICAgICAgdGFnczogWydicmFuY2gnLCAnbGluZScsICdleGNlcHRpb24nXSxcbiAgICAgICAgICBsb2M6IGhhbmRsZXJMb2MsXG4gICAgICAgICAgZ3JvdXAsXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcblxuICAgIGlmIChwYXRoLmhhcygnZmluYWxpemVyJykpIHtcbiAgICAgIHBhdGguZ2V0KCdmaW5hbGl6ZXInKS51bnNoaWZ0Q29udGFpbmVyKCdib2R5JywgZ3VhcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoLmdldCgnZmluYWxpemVyJykucmVwbGFjZVdpdGgodHlwZXMuYmxvY2tTdGF0ZW1lbnQoW2d1YXJkXSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gc3RhdGVtZW50cyBhcmUgaW5zdHJ1bWVudGVkIGJ5IG1hcmtpbmcgdGhlIG5leHQgYmxvY2sgdGhleSByZXR1cm4uXG4gICAqIFRoaXMgaGVscHMgZW5zdXJlIG11bHRpLWxpbmUgZXhwcmVzc2lvbnMgZm9yIHJldHVybiBzdGF0ZW1lbnRzIGFyZVxuICAgKiBhY2N1cmF0ZWx5IGNhcHR1cmVkLlxuICAgKiBAcGFyYW0gICB7W3R5cGVdfSBwYXRoICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAgIHtbdHlwZV19IHN0YXRlIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybnMge1t0eXBlXX0gICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgZnVuY3Rpb24gdmlzaXRSZXR1cm5TdGF0ZW1lbnQocGF0aCwgc3RhdGUpIHtcbiAgICBpZiAoIXBhdGguaGFzKCdhcmd1bWVudCcpKSB7XG4gICAgICBwYXRoLmdldCgnYXJndW1lbnQnKS5yZXBsYWNlV2l0aCh0eXBlcy5zZXF1ZW5jZUV4cHJlc3Npb24oW1xuICAgICAgICBjcmVhdGVNYXJrZXIoc3RhdGUsIHtcbiAgICAgICAgICBsb2M6IHBhdGgubm9kZS5sb2MsXG4gICAgICAgICAgdGFnczogWydsaW5lJywgJ3N0YXRlbWVudCddLFxuICAgICAgICB9KSxcbiAgICAgICAgdHlwZXMuaWRlbnRpZmllcigndW5kZWZpbmVkJyksXG4gICAgICBdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RydW1lbnQocGF0aC5nZXQoJ2FyZ3VtZW50JyksIHN0YXRlLCB7XG4gICAgICAgIHRhZ3M6IFsnbGluZScsICdzdGF0ZW1lbnQnXSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgbXVsdGktbGluZSByZXBvcnRpbmcgKGFuZCBvYmplY3RzIGRvIHRlbmQgdG8gc3BhbiBtdWx0aXBsZSBsaW5lcykgdGhpc1xuICAgKiBpcyByZXF1aXJlZCB0byBrbm93IHdoaWNoIHBhcnRzIG9mIHRoZSBvYmplY3Qgd2hlcmUgYWN0dWFsbHkgZXhlY3V0ZWQuXG4gICAqIElnbm9yZSBzaG9ydGhhbmQgcHJvcGVydHkgdGhhdCBsb29rIGxpa2UgYHsgdGhpcyB9YC5cbiAgICogQHBhcmFtICAge1t0eXBlXX0gcGF0aCAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gICB7W3R5cGVdfSBzdGF0ZSBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm5zIHtbdHlwZV19ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIGZ1bmN0aW9uIHZpc2l0T2JqZWN0UHJvcGVydHkocGF0aCwgc3RhdGUpIHtcbiAgICBpZiAoIXBhdGgubm9kZS5zaG9ydGhhbmQgJiYgIXBhdGgucGFyZW50UGF0aC5pc1BhdHRlcm4oKSkge1xuICAgICAgY29uc3Qga2V5ID0gcGF0aC5nZXQoJ2tleScpO1xuICAgICAgY29uc3QgdmFsdWUgPSBwYXRoLmdldCgndmFsdWUnKTtcbiAgICAgIGlmIChwYXRoLm5vZGUuY29tcHV0ZWQpIHtcbiAgICAgICAgaW5zdHJ1bWVudChrZXksIHN0YXRlLCB7XG4gICAgICAgICAgdGFnczogWydsaW5lJ10sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaW5zdHJ1bWVudCh2YWx1ZSwgc3RhdGUsIHtcbiAgICAgICAgdGFnczogWydsaW5lJ10sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9yIG11bHRpLWxpbmUgcmVwb3J0aW5nIChhbmQgYXJyYXlzIGRvIHRlbmQgdG8gc3BhbiBtdWx0aXBsZSBsaW5lcykgdGhpc1xuICAgKiBpcyByZXF1aXJlZCB0byBrbm93IHdoaWNoIHBhcnRzIG9mIHRoZSBhcnJheSB3aGVyZSBhY3R1YWxseSBleGVjdXRlZC5cbiAgICogVGhpcyBkb2VzIF9ub3RfIGluY2x1ZGUgZGVzdHJ1Y3RlZCBhcnJheXMuXG4gICAqIEBwYXJhbSAgIHtbdHlwZV19IHBhdGggIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICAge1t0eXBlXX0gc3RhdGUgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJucyB7W3R5cGVdfSAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBmdW5jdGlvbiB2aXNpdEFycmF5RXhwcmVzc2lvbihwYXRoLCBzdGF0ZSkge1xuICAgIGlmICghcGF0aC5wYXJlbnRQYXRoLmlzUGF0dGVybigpKSB7XG4gICAgICBwYXRoLmdldCgnZWxlbWVudHMnKS5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgIGluc3RydW1lbnQoZWxlbWVudCwgc3RhdGUsIHtcbiAgICAgICAgICB0YWdzOiBbJ2xpbmUnXSxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9naWNhbCBleHByZXNzaW9ucyBhcmUgdGhvc2UgdXNpbmcgbG9naWMgb3BlcmF0b3JzIGxpa2UgYCYmYCBhbmQgYHx8YC5cbiAgICogU2luY2UgbG9naWMgZXhwcmVzc2lvbnMgc2hvcnQtY2lyY3VpdCBpbiBKUyB0aGV5IGFyZSBlZmZlY3RpdmVseSBicmFuY2hlc1xuICAgKiBhbmQgd2lsbCBiZSB0cmVhdGVkIGFzIHN1Y2ggaGVyZS5cbiAgICogQHBhcmFtIHtbdHlwZV19IHBhdGggIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtIHtbdHlwZV19IHN0YXRlIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiB2aXNpdExvZ2ljYWxFeHByZXNzaW9uKHBhdGgsIHN0YXRlKSB7XG4gICAgY29uc3QgZ3JvdXAgPSBrZXkocGF0aCk7XG4gICAgY29uc3QgdGVzdCA9IHBhdGguc2NvcGUuZ2VuZXJhdGVEZWNsYXJlZFVpZElkZW50aWZpZXIoJ3Rlc3QnKTtcblxuICAgIHBhdGgucmVwbGFjZVdpdGgoWCh0eXBlcy5jb25kaXRpb25hbEV4cHJlc3Npb24oXG4gICAgICB0eXBlcy5hc3NpZ25tZW50RXhwcmVzc2lvbignPScsIHRlc3QsIFgocGF0aC5ub2RlKSksXG4gICAgICB0eXBlcy5zZXF1ZW5jZUV4cHJlc3Npb24oW2NyZWF0ZU1hcmtlcihzdGF0ZSwge1xuICAgICAgICB0YWdzOiBbJ2JyYW5jaCcsICdsb2dpYyddLFxuICAgICAgICBsb2M6IHBhdGguZ2V0KCdsZWZ0Jykubm9kZS5sb2MsXG4gICAgICAgIGdyb3VwLFxuICAgICAgfSksIHRlc3RdKSxcbiAgICAgIHR5cGVzLnNlcXVlbmNlRXhwcmVzc2lvbihbY3JlYXRlTWFya2VyKHN0YXRlLCB7XG4gICAgICAgIHRhZ3M6IFsnYnJhbmNoJywgJ2xvZ2ljJ10sXG4gICAgICAgIGxvYzogcGF0aC5nZXQoJ3JpZ2h0Jykubm9kZS5sb2MsXG4gICAgICAgIGdyb3VwLFxuICAgICAgfSksIHRlc3RdKVxuICAgICkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25kaXRpb25hbHMgYXJlIGVpdGhlciBpZi9lbHNlIHN0YXRlbWVudHMgb3IgdGVuYWlhcnkgZXhwcmVzc2lvbnMuIFRoZXlcbiAgICogaGF2ZSBhIHRlc3QgY2FzZSBhbmQgdHdvIGNob2ljZXMgKGJhc2VkIG9uIHRoZSB0ZXN0IHJlc3VsdCkuIEJvdGggY2FzZXNcbiAgICogYXJlIGFsd2F5cyBhY2NvdW50ZWQgZm9yLCBldmVuIGlmIHRoZSBjb2RlIGRvZXMgbm90IGV4aXN0IGZvciB0aGUgYWx0ZXJuYXRlXG4gICAqIGNhc2UuXG4gICAqIEBwYXJhbSB7W3R5cGVdfSBwYXRoICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSB7W3R5cGVdfSBzdGF0ZSBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24gdmlzaXRDb25kaXRpb25hbChwYXRoLCBzdGF0ZSkge1xuICAgIC8vIEJyYW5jaGVzIGNhbiBiZSBncm91cGVkIHRvZ2V0aGVyIHNvIHRoYXQgZWFjaCBvZiB0aGUgcG9zc2libGUgYnJhbmNoXG4gICAgLy8gZGVzdGluYXRpb25zIGlzIGFjY291bnRlZCBmb3IgdW5kZXIgb25lIGdyb3VwLiBGb3IgaWYgc3RhdGVtZW50cywgdGhpc1xuICAgIC8vIHJlZmVycyB0byBhbGwgdGhlIGJsb2NrcyB0aGF0IGZhbGwgdW5kZXIgYSBzaW5nbGUgaWYuLiBlbHNlIGlmLi4gZWxzZS4uXG4gICAgLy8gZ3JvdXBpbmcuXG4gICAgY29uc3Qgcm9vdCA9IHBhdGguZmluZFBhcmVudCgoc2VhcmNoKSA9PiB7XG4gICAgICByZXR1cm4gc2VhcmNoLm5vZGUudHlwZSA9PT0gcGF0aC5ub2RlLnR5cGUgJiZcbiAgICAgICAgIWlnbm9yZShzZWFyY2gpICYmXG4gICAgICAgICghc2VhcmNoLnBhcmVudFBhdGggfHwgc2VhcmNoLnBhcmVudFBhdGgubm9kZS50eXBlICE9PSBwYXRoLm5vZGUudHlwZSk7XG4gICAgfSkgfHwgcGF0aDtcblxuICAgIC8vIENyZWF0ZSB0aGUgZ3JvdXAgbmFtZSBiYXNlZCBvbiB0aGUgcm9vdCBgaWZgIHN0YXRlbWVudC5cbiAgICBjb25zdCBncm91cCA9IGtleShyb290KTtcblxuICAgIGZ1bmN0aW9uIHRhZ0JyYW5jaChwYXRoKSB7XG4gICAgICBhZGRSdWxlcyhzdGF0ZSwgcGF0aC5ub2RlLmxvYywgcGF0aC5ub2RlLmxlYWRpbmdDb21tZW50cyk7XG4gICAgICBpZiAocGF0aC5pc0Jsb2NrU3RhdGVtZW50KCkgJiYgcGF0aC5ub2RlLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICBhZGRSdWxlcyhzdGF0ZSwgcGF0aC5ub2RlLmxvYywgcGF0aC5ub2RlLmJvZHlbMF0ubGVhZGluZ0NvbW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0YWdCcmFuY2gocGF0aC5nZXQoJ2NvbnNlcXVlbnQnKSk7XG4gICAgaWYgKHBhdGguaGFzKCdhbHRlcm5hdGUnKSkge1xuICAgICAgdGFnQnJhbmNoKHBhdGguZ2V0KCdhbHRlcm5hdGUnKSk7XG4gICAgfVxuXG4gICAgaW5zdHJ1bWVudChwYXRoLmdldCgnY29uc2VxdWVudCcpLCBzdGF0ZSwge1xuICAgICAgdGFnczogWydicmFuY2gnLCAnbGluZScsICdpZiddLFxuICAgICAgbG9jOiBwYXRoLm5vZGUuY29uc2VxdWVudC5sb2MsXG4gICAgICBncm91cCxcbiAgICB9KTtcblxuICAgIGlmIChwYXRoLmhhcygnYWx0ZXJuYXRlJykgJiYgIXBhdGguZ2V0KCdhbHRlcm5hdGUnKS5pc0lmU3RhdGVtZW50KCkpIHtcbiAgICAgIGluc3RydW1lbnQocGF0aC5nZXQoJ2FsdGVybmF0ZScpLCBzdGF0ZSwge1xuICAgICAgICB0YWdzOiBbJ2JyYW5jaCcsICdsaW5lJywgJ2lmJ10sXG4gICAgICAgIGxvYzogcGF0aC5ub2RlLmFsdGVybmF0ZS5sb2MsXG4gICAgICAgIGdyb3VwLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghcGF0aC5oYXMoJ2FsdGVybmF0ZScpKSB7XG4gICAgICBwYXRoLmdldCgnYWx0ZXJuYXRlJykucmVwbGFjZVdpdGgodHlwZXMuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgICAgY3JlYXRlTWFya2VyKHN0YXRlLCB7XG4gICAgICAgICAgdGFnczogWydicmFuY2gnLCAnaWYnXSxcbiAgICAgICAgICBsb2M6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBwYXRoLm5vZGUubG9jLmVuZCxcbiAgICAgICAgICAgIGVuZDogcGF0aC5ub2RlLmxvYy5lbmQsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBncm91cCxcbiAgICAgICAgfSkpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vSW5zdHJ1bWVudChwYXRoKSB7XG4gICAgaWYgKFxuICAgICAgcGF0aC5ub2RlICYmXG4gICAgICBwYXRoLm5vZGUubGVhZGluZ0NvbW1lbnRzICYmXG4gICAgICBwYXRoLm5vZGUubGVhZGluZ0NvbW1lbnRzLnNvbWUoXG4gICAgICAgIChjb21tZW50KSA9PiAvXlxccyphZGFuYS1uby1pbnN0cnVtZW50XFxzKiQvLmV4ZWMoY29tbWVudC52YWx1ZSlcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHBhdGguc2tpcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHZpc2l0b3IgPSB7XG4gICAgLy8gRXhwcmVzc2lvbnNcbiAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogdmlzaXRGdW5jdGlvbixcbiAgICBGdW5jdGlvbkV4cHJlc3Npb246IHZpc2l0RnVuY3Rpb24sXG4gICAgT2JqZWN0TWV0aG9kOiB2aXNpdEZ1bmN0aW9uLFxuICAgIENsYXNzTWV0aG9kOiB2aXNpdEZ1bmN0aW9uLFxuICAgIExvZ2ljYWxFeHByZXNzaW9uOiB2aXNpdExvZ2ljYWxFeHByZXNzaW9uLFxuICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogdmlzaXRDb25kaXRpb25hbCxcbiAgICBPYmplY3RQcm9wZXJ0eTogdmlzaXRPYmplY3RQcm9wZXJ0eSxcbiAgICBBcnJheUV4cHJlc3Npb246IHZpc2l0QXJyYXlFeHByZXNzaW9uLFxuXG4gICAgLy8gRGVjbGFyYXRpb25zXG4gICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogdmlzaXRGdW5jdGlvbixcbiAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiB2aXNpdFZhcmlhYmxlRGVjbGFyYXRpb24sXG5cbiAgICAvLyBTdGF0ZW1lbnRzXG4gICAgQ29udGludWVTdGF0ZW1lbnQ6IHZpc2l0U3RhdGVtZW50LFxuICAgIEJyZWFrU3RhdGVtZW50OiB2aXNpdFN0YXRlbWVudCxcbiAgICBFeHByZXNzaW9uU3RhdGVtZW50OiB2aXNpdFN0YXRlbWVudCxcbiAgICBUaHJvd1N0YXRlbWVudDogdmlzaXRTdGF0ZW1lbnQsXG4gICAgUmV0dXJuU3RhdGVtZW50OiB2aXNpdFJldHVyblN0YXRlbWVudCxcbiAgICBUcnlTdGF0ZW1lbnQ6IHZpc2l0VHJ5U3RhdGVtZW50LFxuICAgIFdoaWxlU3RhdGVtZW50OiB2aXNpdFdoaWxlTG9vcCxcbiAgICBEb1doaWxlU3RhdGVtZW50OiB2aXNpdFdoaWxlTG9vcCxcbiAgICBJZlN0YXRlbWVudDogdmlzaXRDb25kaXRpb25hbCxcbiAgICBTd2l0Y2hTdGF0ZW1lbnQ6IHZpc2l0U3dpdGNoU3RhdGVtZW50LFxuXG4gICAgLy8gR2VuZXJpY3NcbiAgICBlbnRlcjogbm9JbnN0cnVtZW50LFxuICB9O1xuXG4gIE9iamVjdC5rZXlzKHZpc2l0b3IpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHZpc2l0b3Jba2V5XSA9IHN0YW5kYXJkaXplKHZpc2l0b3Jba2V5XSk7XG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgYWN0dWFsIGJhYmVsIHBsdWdpbiBvYmplY3QuXG4gIHJldHVybiB7XG4gICAgdmlzaXRvcjoge1xuICAgICAgUHJvZ3JhbShwYXRoLCBzdGF0ZSkge1xuICAgICAgICAvLyBDaGVjayBpZiBmaWxlIHNob3VsZCBiZSBpbnN0cnVtZW50ZWQgb3Igbm90LlxuICAgICAgICBpZiAoc2tpcChzdGF0ZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWV0YShzdGF0ZSwge1xuICAgICAgICAgIHNvdXJjZTogc3RhdGUuZmlsZS5jb2RlLFxuICAgICAgICAgIGVudHJpZXM6IFtdLFxuICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICB0YWdzOiB7fSxcbiAgICAgICAgICB2YXJpYWJsZTogcGF0aC5zY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoJ2NvdmVyYWdlJyksXG4gICAgICAgIH0pO1xuICAgICAgICBwYXRoLnRyYXZlcnNlKHZpc2l0b3IsIHN0YXRlKTtcbiAgICAgICAgYXBwbHlSdWxlcyhzdGF0ZSk7XG4gICAgICAgIHBhdGgudW5zaGlmdENvbnRhaW5lcignYm9keScsIHByZWx1ZGUoc3RhdGUpKTtcbiAgICAgIH0sXG4gICAgfSxcbiAgfTtcbn1cbiJdfQ==